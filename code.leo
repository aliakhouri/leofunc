<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="sa.20090412004607.1"><vh>@chapters</vh></v>
<v t="sa.20091017143710.1576"><vh>@enabled-plugins</vh></v>
<v t="sa.20090331175551.7"><vh>buttons</vh>
<v t="sa.20090331175551.3"><vh>@button create_docs</vh></v>
<v t="sa.20090331175551.4"><vh>@button remove_docs</vh></v>
<v t="sa.20090404125157.1"><vh>@button open_docs</vh></v>
<v t="sa.20090403012706.80"><vh>@button run_tests</vh></v>
</v>
<v t="sa.20090331175400.19" a="E"><vh>doc</vh>
<v t="sa.20090331175551.2"><vh>@rst index</vh></v>
<v t="sa.20090321144048.1" a="E"><vh>@rst overview</vh>
<v t="sa.20090327150331.1"><vh>Functional Directives in Leo</vh></v>
<v t="sa.20090322205020.4" a="E"><vh>A Graphical Walkthrough</vh>
<v t="sa.20090408102856.1"><vh>The Basic Elements</vh></v>
<v t="sa.20090409180909.1"><vh>Text and Namespaces</vh></v>
<v t="sa.20090408102856.5"><vh>The Analytical Outcome</vh></v>
<v t="sa.20090408102856.4"><vh>The Big Picture</vh></v>
</v>
<v t="sa.20090413173014.3"><vh>Usage Patterns</vh></v>
<v t="sa.20090413173014.1"><vh>Implementation</vh></v>
<v t="sa.20090413173014.2"><vh>Tutorial</vh></v>
<v t="sa.20090405022902.1"><vh>Illustrative Examples</vh>
<v t="sa.20090413173014.4"><vh>@py and @pyc</vh></v>
<v t="sa.20090325055709.2"><vh>@imports</vh></v>
<v t="sa.20090411210049.7"><vh>@rss</vh></v>
<v t="sa.20090411210049.8"><vh>@pipe</vh></v>
<v t="sa.20090411210049.12"><vh>@csum</vh></v>
</v>
<v t="sa.20090412021930.1"><vh>Known Issues</vh>
<v t="sa.20090412181407.2"><vh>Poor integration with Leo</vh></v>
<v t="sa.20090412181407.3"><vh>Whitespace prohibited in a directive call</vh></v>
</v>
</v>
<v t="sa.20090331175551.5"><vh>modules</vh>
<v t="sa.20090331175551.6"><vh>@rst index</vh></v>
<v t="sa.20090331182350.1"><vh>@rst leofunc</vh></v>
<v t="sa.20090411210049.9"><vh>@rst test_leofunc</vh></v>
</v>
</v>
<v t="sa.20090331175400.20"><vh>code</vh>
<v t="sa.20090412003618.11"><vh>experimental</vh>
<v t="sa.20090412152038.1"><vh>test_pyparse.py</vh></v>
</v>
<v t="sa.20090403012613.1"><vh>@shadow leofunc.py</vh></v>
<v t="sa.20090403012613.2"
expanded="sa.20090403194916.1,"><vh>@shadow test_leofunc.py</vh></v>
<v t="sa.20091017143710.1563"
expanded="sa.20091017143710.1570,"><vh>@thin leofunc_plugin.py</vh></v>
</v>
<v t="sa.20090412220044.1"><vh>leo</vh>
<v t="sa.20090404001050.1"><vh>tree transformations</vh>
<v t="sa.20090403232618.4"><vh>s1</vh></v>
<v t="sa.20090403222930.4"><vh>s2</vh></v>
</v>
<v t="sa.20090403190352.1"><vh>simulation</vh>
<v t="sa.20090403224444.2"><vh>imports</vh>
<v t="sa.20090403203844.46"><vh>an @imports block</vh></v>
<v t="sa.20090403222930.6"><vh>@imports import os</vh></v>
<v t="sa.20090403224444.1"><vh>@imports toad = "love"</vh></v>
</v>
<v t="sa.20090403213738.1"><vh>expressions</vh>
<v t="sa.20090403190352.2"><vh>@py 'Hello'.upper()</vh></v>
<v t="sa.20090403222144.3"><vh>@py greetings</vh></v>
<v t="sa.20090403214411.1"><vh>@pyc c = 1</vh></v>
<v t="sa.20090403203844.45"><vh>@py 12 * 32</vh></v>
<v t="sa.20090403203844.47"><vh>@py 21 * z</vh></v>
<v t="sa.20090403221202.2"><vh>@py lambda x: x+1</vh></v>
<v t="sa.20090403222144.1"><vh>@py range(100)</vh></v>
<v t="sa.20090403222144.4"><vh>@py nice(1)</vh></v>
<v t="sa.20090403224444.3"><vh>@py "I %s leo" % toad</vh></v>
<v t="sa.20090403224444.4"><vh>@py os.getcwd()</vh></v>
</v>
<v t="sa.20090403213738.2"><vh>blocks</vh>
<v t="sa.20090403190352.3"><vh>a block of python code</vh></v>
</v>
<v t="sa.20090403213738.3"><vh>pipes</vh>
<v t="sa.20090403212746.1"><vh>@pipe 'ok' | upper</vh></v>
</v>
<v t="sa.20090405090633.1"><vh>templates</vh>
<v t="sa.20090405090633.2"><vh>love</vh></v>
</v>
<v t="sa.20090408220321.1"><vh>docs</vh></v>
</v>
<v t="sa.20111215010755.1632" a="E"><vh>test</vh>
<v t="sa.20111215010755.1654"><vh>@pyc import os</vh>
<v t="sa.20111215010755.1655"><vh>a basic headline</vh></v>
</v>
<v t="sa.20111215010755.1656" a="E"><vh>a block of python code</vh>
<v t="sa.20111215010755.1657"><vh>@tmpl this a=$a is embedded in the body</vh></v>
<v t="sa.20111215010755.1658"><vh>@pipe 'd' | upper</vh></v>
</v>
</v>
<v t="sa.20111215010755.1638"><vh>test2</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="sa.20090321144048.1"></t>
<t tx="sa.20090322205020.4">Since we are introducing a simplified model of leo, it may be useful to have a look at some of its elements in a graphical way ( a great excuse to use Sphinx's cool graphing feature :-)</t>
<t tx="sa.20090325055709.2">@imports updates the tree.namespace with objects and data which are accessible by all instances of LeoNode.

A shortened synonym for this directive is @pg or python-global.

All LeoElements have access to the @imports node's namespace during the evaluation or execution of code. It is implemented as follows::

    # evaluator functions as directives
    @directive('imports', 'py-imports')
    def eval_py_imports(**kwds):
        def _eval_py_imports(element):
            element.node.tree.namespace.update(kwds)
            exec element.code in element.node.tree.namespace
        return _eval_py_imports

We see that the block of python code is ``exec``'ed in the tree namespace.
</t>
<t tx="sa.20090327150331.1">**leo directives as python callables**

This document explores a concept for `leo-editor`_ which aims to collapse the distinction between `leo directives`_ and python callables.


**Why would one want to do this?**

To add even more power to Leo of course (-:

Here are some possible benefits:

- Makes it easier to create custom directives in a leo document.

- Adds a new dimension of scriptability to leo: directives are callables, they have access to the full power of python programming; 

- Since callables can also be part of a module or namespace, it will be easier to group useful directives into libraries.

- A leo head or body can have multiple 'views' which are rendered as a result of evaluating its embedded code.

- Easily create text/tree transformers in leo using functional pipelines. 

- Simplifies batch pre/processing/piping of data in leo nodes (for macros, templates, leoapps? ..) 

- Makes it easier to create Domain Specific Languages [DSLs]

- &lt;add more benefits&gt;

Since this particular conception of leo directives mostly operate in a functional way on leo elements, we call them *functional directives*.

These types of directives are implemented as a python callable with a particular signature that gets registered by the :obj:`leofunc.directive` decorator.

.. note:: This is merely a simulation. We have not yet really considered compatibility issues, current implementation details of leo, or how the functional directives will work with the current style of leo directives.

This model only works in a much-simplified simulation of leo implemented in :mod:`leofunc` and tested in :mod:`test_leofunc`. Alas, I still do not converse well with Leo's innards, so this really is (at this stage) just an extended thought exercise with code. If there is support for this concept, I would appreciate any help to integrate it more closely with leo.

Documentation has been generated from reStructuredText source markup using a combination of `leo-editor`_ and `Sphinx`_ 

.. _`leo-editor`: http://webpages.charter.net/edreamleo/front.html
.. _`leo directives`: http://webpages.charter.net/edreamleo/intro.html#leo-directives
.. _`Sphinx`: http://sphinx.pocoo.org/ 


</t>
<t tx="sa.20090331175400.19">@ @rst-options
default_path=doc
write_intermediate_file=True
show_headlines=True
@c

@language rest

</t>
<t tx="sa.20090331175400.20"></t>
<t tx="sa.20090331175551.2">============================
Functional-Leo Documentation
============================

Contents
==========

.. toctree::
   :maxdepth: 2

   overview.txt

   modules/index.txt
   

Indices and tables
===================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`</t>
<t tx="sa.20090331175551.3">import os
c.executeMinibufferCommand('rst3')
os.system('cd doc; make html')

</t>
<t tx="sa.20090331175551.4">import os
cmds = [
    'rm -rf doc/_build/*',
    'rm -rf doc/*.txt',
    'rm -rf doc/modules/*.txt'
]

for cmd in cmds:
    os.system(cmd)
</t>
<t tx="sa.20090331175551.5">@ @rst-options
default_path=doc/modules
@c
</t>
<t tx="sa.20090331175551.6">
=====================
Functional-Leo Modules
=====================

.. contents::

leofunc
==========

.. toctree::
   :maxdepth: 2

   leofunc.txt
   test_leofunc.txt

Indices and tables
===================
* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
</t>
<t tx="sa.20090331175551.7"></t>
<t tx="sa.20090331182350.1">
.. _leofunc:

:mod:`leofunc` -- a simulation of the suggested functionality 
================================================================================

.. automodule:: leofunc
   :synopsis: a simulation of the suggested functionality.
   :members:
   

</t>
<t tx="sa.20090403012706.80">import os
os.system('./runtests')</t>
<t tx="sa.20090403190352.1">import leofunc

def load(g, p):
    nodes = []

    for i in p.subtree_iter():
        n = leofunc.Node(head=i.h, body=i.b)
        nodes.append(n)

    g.es(len(nodes))

    for node in nodes:
        g.es(node)
        node.render()
        g.es("head.view:", node.head.view)
        g.es("body.view:", node.body.view)
        g.es("-"*50)

load(g,p)


</t>
<t tx="sa.20090403190352.2">@py 'some lovely texts'.upper()

</t>
<t tx="sa.20090403190352.3">@pyc
node.body.data = a * 2132
@

some data in the body

</t>
<t tx="sa.20090403203844.45"></t>
<t tx="sa.20090403203844.46">@imports

z = 21

greetings = "I love you!"

def nice(x):
    return x+2

@

You could write something meaningful here but ..
</t>
<t tx="sa.20090403203844.47"></t>
<t tx="sa.20090403212746.1"></t>
<t tx="sa.20090403213738.1"></t>
<t tx="sa.20090403213738.2"></t>
<t tx="sa.20090403213738.3"></t>
<t tx="sa.20090403214411.1">@py c + 1</t>
<t tx="sa.20090403221202.2"></t>
<t tx="sa.20090403222144.1"></t>
<t tx="sa.20090403222144.3"></t>
<t tx="sa.20090403222144.4"></t>
<t tx="sa.20090403222930.4">from leofunc import Node

class LeoNode(Node):

    def make_tree(self):
        try:
            self.tree_walk(self)
        finally:
            c.redraw()

    def tree_walk(self, node, parent=None, isroot=True):
        if isroot:
            rhead = node.head.text
            rbody = node.body.text
            root = p.insertAsLastChild()
            root.initHeadString(rhead)
            root.initBodyString(rbody)
            parent = root
            
        for child in node.children:
            headline = child.head.text
            body = child.body.text
            if parent:
                node = parent
            else:
                node = p
            child1 = node.insertAsLastChild()
            child1.initHeadString(headline)
            child1.initBodyString(body)
            self.tree_walk(child, parent=child1, isroot=False)

t1 = LeoNode('a','b')
t2 = LeoNode('c','d')
t3 = LeoNode('e','f')
t4 = LeoNode('g','h')

t1.children=[t2, t3]
t3.children=[t4]
t1.make_tree()
</t>
<t tx="sa.20090403222930.6"></t>
<t tx="sa.20090403224444.1"></t>
<t tx="sa.20090403224444.2"></t>
<t tx="sa.20090403224444.3"></t>
<t tx="sa.20090403224444.4"></t>
<t tx="sa.20090403232618.4">from test_leofunc import tree1

def mktree(node, parent=None, isroot=True, p=None):
    body = node.body.text
    for child in node.children:
        headline = child.head.text
        body = child.body.text
        if parent:
            node = parent
        else:
            node = p
        child1 = node.insertAsLastChild()
        child1.initHeadString(headline)
        child1.initBodyString(body)
        mktree(child, parent=child1, isroot=False)

def make_leo_tree(node, c):
    try:
        mktree(node, p=c.p)
    finally:
        c.redraw()

make_leo_tree(tree1, c)

</t>
<t tx="sa.20090404001050.1"></t>
<t tx="sa.20090404125157.1">import os
os.system('firefox ./doc/_build/html/index.html')</t>
<t tx="sa.20090405022902.1">The following examples of custom functional directives are implemented in :file:`leofunc.py` and tested in :file:`test_leofunc.py`. Both files include further examples and tests of other leo directives. Of course, you can just look at the code section of :file:`code.leo`.

</t>
<t tx="sa.20090405090633.1"></t>
<t tx="sa.20090405090633.2">@xt('cheetah',z=10)

a nice big $z

@

Wouln't it be nice to love somebody

</t>
<t tx="sa.20090408102856.1">An element is part of a node is part of a tree.

.. graphviz:: 

    digraph a {
    
        node [fontsize=10, fontname=Helvetica];
        "element" -&gt; "node";
        "node" -&gt; "node";
        "node" -&gt; "tree";
    }</t>
<t tx="sa.20090408102856.4">In the context of leo, an element is either a head or body of a node.

.. graphviz:: 

    digraph e {
    
        node [fontsize=8, fontname=Helvetica];
        
        "node" -&gt; "head";
        "head" -&gt; "head.directive";
        "head" -&gt; "head.code";
        "head" -&gt; "head.data";
        "head" -&gt; "head.text";
        
        "node" -&gt; "body";
        "body" -&gt; "body.directive";
        "body" -&gt; "body.code";
        "body" -&gt; "body.data";
        "body" -&gt; "body.text";
    
        "node" -&gt; "node";
        "node" -&gt; "node.namespace";
        
        "node" -&gt; "tree";
        "tree" -&gt; "tree.namespace";
    }</t>
<t tx="sa.20090408102856.5">When an element is created its text is parsed to populate its directive, code and data attributes.

.. graphviz:: 

    digraph d {
    
        node [fontsize=8, fontname=Helvetica];
        "element" -&gt; "node";
        "element" -&gt; "element.text"; 
        "element" -&gt; "element.directive";
        "element" -&gt; "element.code";
        "element" -&gt; "element.data";
        "node" -&gt; "node";
        "node" -&gt; "node.namespace";
        "node" -&gt; "tree";
        "tree" -&gt; "tree.namespace";
    }</t>
<t tx="sa.20090408220321.1">@doc
There was an early things we wanted to do
friendly he said
@

Like now
    </t>
<t tx="sa.20090409180909.1">The key thing about an element is that it stores raw text that can be parsed. If correctly parsed, it can be evaluated in the context of two python namespaces (the node-specific or 'local' namespace and the tree namespace, which is commonly accessible or 'global' to all elements in the tree.

.. graphviz:: 

    digraph c {
    
        node [fontsize=10, fontname=Helvetica];
        "element" -&gt; "node";
        "element" -&gt; "element.text"; 
        "node" -&gt; "node";
        "node" -&gt; "node.namespace";
        "node" -&gt; "tree";
        "tree" -&gt; "tree.namespace";
    }</t>
<t tx="sa.20090411210049.12">Following from the earlier @py example, we create a custom @csum directive which can be used this way::

    +-- root
         |
         +-- @csum sandwhich
         |     |
         |     +-- bread = 100
         |     |
         |     +-- beetroots = 16
         |     |
         |     +-- pigeon = 20
         |
         

The @csum node renders (or evaluates) to 136 by creating a dictionary called 'sandwhich' in node.namespace and summing its values. This directive is implemented in this messy function::

    @directive('csum', 'csum-expr')
    def eval_csum(**kwds):
        def _eval_csum(element):
            sumd = lambda d: sum(d[k] for k in d)
            if element.code:
                d = element.node.namespace[element.code] = {}
            else:
                d = {}
            lst = []
            for child in element.node.children:
                head = child.head.view
                lst.append(head)
                body = child.body.view
                lst.append(body)
            assigns = '\n'.join(lst)
            exec assigns in d
            del d['__builtins__']
            return sumd(d)
        return _eval_csum
    
</t>
<t tx="sa.20090411210049.7">Here's a trivial example of a directive which dumps an rss feed into the default view ::

    @directive('rss', 'rss-feed')
    def eval_rss(**kwds):
        """ creates and registers an @rss directive
        """ 
        def _eval_rss(element):
            import urllib
            feed = urllib.urlopen(element.code).read()
            return feed
        return _eval_rss

We can then use this directive as follows::

    +-- root
         |
         +-- @rss http://planet.python.org/rss10.xml
         |         
         |
</t>
<t tx="sa.20090411210049.8">We would like to introduce @pipe which look like this::
    
    @pipe node.children | sorted | to.children

which is exactly equivalent to::

    @py to.children(sorted(node.children))
    
this should just work as well::
    
    @py node.children.sort()

Of course, you could just wrap all the above functionality into a single directive and call it @sort::

    @sort
    

Look in ``test_leofunc.py`` for further examples of @pipe usage.</t>
<t tx="sa.20090411210049.9">
.. _test_leofunc:

:mod:`test_leofunc` -- tests of the functionality.
================================================================================

.. automodule:: test_leofunc
   :synopsis: tests of the functionality.
   :members:
   </t>
<t tx="sa.20090412003618.11">

</t>
<t tx="sa.20090412004607.1"></t>
<t tx="sa.20090412021930.1">

</t>
<t tx="sa.20090412152038.1">from pyparsing import *
# from leofunc import PATTERNS
import re

# from pyparsing import Literal, Group, OneOrMore, restOfLine

parse_data = lambda toks: toks.asDict()

PARSE_FUNCS = {}

class Bunch(dict):
    __getattr__ = dict.__getitem__
    

def define(name, obj, func=None):
    if not func:
        func = PARSE_FUNCS.get(name) 
        # if not func:
        #     func = lambda toks: toks
    else:
        PARSE_FUNCS[name] = func
    return obj.setResultsName(name)#.setParseAction(func)

def defsequence(labels, funcs):
    parsers = Bunch()
    for label, func in zip(labels, funcs):
        parsers[label] = define(label, func)
    return parsers

word = Word(printables)
words = OneOrMore(word)
directive = Literal('@') + word
line   = directive + restOfLine
sentinel  = LineEnd() + Literal('@') + LineEnd()
data      = words + LineEnd()
code      = words + LineEnd()
block = (
        line 
        + Optional(code) 
        + Optional(sentinel) 
        + Optional(data)
        )

labels = ['word', 'words', 'directive', 'line', 'sentinel', 'data', 'code', 'block']
funcs = [word, words, directive, line, sentinel, data, code, block]
parsers = defsequence(labels, funcs)

ts = dict(
    t0 = '@py',
    t1 = '@py(a=1,b=f())   hello there',
    t2 = '@py(f(10),a=10,b=60) hello\n@\n goodbye then\n',
    t3 = '@pyc hello there \n@py 1+1\nwhat is going on',
    t4 = '@py(a=1,b=2,f()) ok',
    t5 = '@py.tool(a=1,s=3) sd',
    t6 = '@py.tool(a=1,s="3") sd',
    t7 = '@py(a=1,s=2)',
)


from pprint import pprint
results = []
for i in sorted(ts):
    results.append((i, parsers.block.parseString(ts[i])))

for i, j in results:
    # print i, j.asList()
    print i, j.asDict()

# line = PATTERNS['line']
# block = PATTERNS['block']

# 
# for i in sorted(ts):
#     m = line.match(ts[i])
#     if m:
#         print 'line:'.upper()
#         print i, ts[i]
#     m = block.match(ts[i])
#     
#     if m:
#         print 'block:'.upper()
#         print i, ts[i]
# 
# 
#         
</t>
<t tx="sa.20090412181407.2">Open Questions:

* Is this a good idea?

* If so, how to properly introduce leo directives into leo: at what level of integration and in what form?
    
* Script/Button/Command?

* Seamlessly?

* If not, then perhaps different symbol to not confuse with current implementation?

* Drop it. (-:

In any case, initial efforts to integrate the concept into Leo proper have only produced a small number of very limited leo scripts which are contained in :file:`code.leo`:

**tree transformations**

``s1``: populates a proper leo node from a predefined tree (bug/feature: skips first node)

``s2``: attempt at a class-based version of ``s1``

**simulation**

This is a nice way to see how leo nodes defined with functional directives would look like. The leo script recursively iterates over the child nodes and creates functional nodes for testing.</t>
<t tx="sa.20090412181407.3">If you are passing arguments to a directive you **cannot** include whitespace in the call::

    @py(a=1, b=2)
    
This is due to current limitations of the parser (any help would be appreciated :-)

You will have to write it this way::

    @py(a=1,b=2)


</t>
<t tx="sa.20090412220044.1"></t>
<t tx="sa.20090413173014.1">A leo functional directive is implemented as a python callable returning a callable accepting a leo element. 

A leo element is an instance of :class:`leofunc.Element` (a head or a body object) contained in a :class:`leofunc.Node` instance.

This basic example defines a function ``func`` which implements a directive ``@elem`` registered by the :obj:`leofunc.directive` decorator. The purpose of this directive is to simply return the element from which it is called::

    @directive('elem')
    def func(*args, **kwds):
        def _func(element):
            return element
        return _func

.. note:: To create a directive which takes optional arguments is to define both ``*args`` and ``**kwds`` or just ``**kwds``. Note that we cannot presently define funcs which do not take parameters. Even if optional args or kwds are not eventually used in the function, this specific signature is required for this implementation. 

There is a more concise but less readable lambda version::

    func = directive('elem')(lambda *args, **kwds: lambda element: element)


We could use this directive in a leo tree as follows::

    +-- root
         |
         +-- @elem
         |         
         +-- @elem(a,b,c='value')
         |         
         +-- @elem
         |         


but it's not very useful at this stage since evaluating this directive will always return the head object for each case.</t>
<t tx="sa.20090413173014.2">Now to do something useful: the obligatory hello world as a leo functional directive.

In a directory containing :file:`leofunc.py` fire up python or ipython and enter this::
 
    &gt;&gt;&gt; from leofunc import Node, directive
    &gt;&gt;&gt; @directive('hello', 'hello-expr')
    ... def eval_hello(world):
    ...     def _eval_hello(element):
    ...         return 'hello %s' % world
    ...     return _eval_hello
    ... 
    &gt;&gt;&gt; n = Node("@hello('leo')")
    &gt;&gt;&gt; n
     &lt;Node  [@hello('leo')]&gt;
    &gt;&gt;&gt; n.head.directive
    "hello('leo')"
    &gt;&gt;&gt; n.head.code
    ''
    &gt;&gt;&gt; n.head.data
    ''
    &gt;&gt;&gt; n.head.text
    "@hello('leo')"
    &gt;&gt;&gt; n.head.type
    'hello-expr'
    &gt;&gt;&gt; n.head.view
    hello leo
    &gt;&gt;&gt; 

</t>
<t tx="sa.20090413173014.3">A leo functional directive has two *tentative* forms:

The first is the single line version::

    @&lt;directive&gt; &lt;code&gt;

The second form is for block or suite versions and are possible only for body elements::

    @&lt;directive&gt;
    &lt;code&gt;
    @
    &lt;data&gt;

The ``&lt;directive&gt;`` is implemented as a python callable that is either in a :attr:`leofunc.Tree.namespace` or in a :attr:`leofunc.Node.namespace`. Heads and bodies share a common :attr:`leofunc.Node.namespace`. 

In the single line version of a directive, ``&lt;code&gt;`` is a string that follows the ``&lt;directive&gt;`` and is terminated by ``\n``. 

In the body version, ``&lt;code&gt;`` consists of all ``\n`` terminated strings which extend from the end of the first line (containing the directive) and finally terminate with ``\n@\n``. The ``&lt;data&gt;`` section is everything that follows.

Obviously, we can only have the single line version in a head (or headline), but both forms can happily exist in the body of a node.
</t>
<t tx="sa.20090413173014.4">Let's start with some code::

    &gt;&gt;&gt; from leofunc import Node
    &gt;&gt;&gt; node = Node(head='@py 1+1+a', body='@pyc a=2')
    &gt;&gt;&gt; # we render body first to populate node.namespace
    &gt;&gt;&gt; # and give the head access to the 'a' variable
    &gt;&gt;&gt; node.body.render()
    &gt;&gt;&gt; node.head.directive
    'py'
    &gt;&gt;&gt; node.head.code
    '1+1+a'
    &gt;&gt;&gt; node.head.data
    ''
    &gt;&gt;&gt; node.head.view
    4
    &gt;&gt;&gt; node.body.directive
    'pyc'
    &gt;&gt;&gt; node.body.type
    'py-suite'
    &gt;&gt;&gt; node.body.code
    'a=2'
    &gt;&gt;&gt; node.body.view
    &gt;&gt;&gt; assert 'a' in node.namespace
    &gt;&gt;&gt; 

In this case, we have defined a ``py-expr`` or python expression for the head of a node and a ``py-suite`` or python code block for its body.

It may be useful to briefly look into the implementation of @py ::

    @directive(symbol='py', type='py-expr')
    def eval_py_expression(**kwds):
        """ creates and registers a @py directive
        """
        def _eval_py_expression(element):
            namespace = element.get_namespace(**kwds)
            return eval(element.code, globals(), namespace)
        return _eval_py_expression

The @directive decorator registers this function in a global dictionary called DIRECTIVES. The eval_py_expression function takes optional keyword arguments which update the namespace and returns a function which operates on a leo element. This is the signature for a leo functional directive. It must (as a matter of mere implementation) accept only elements, which are the typical subcomponents of a LeoNode (e.g. head and body). This is not a loss since element-level code can theoretically climb up or down the tree and access any other node.

The ``@py`` directive which allows us to evaluate arbitrary python expressions which may or may not return data and treat parts of a leo outline as a kind of program::

    +-- root
         |
         +-- @py sum(child.head.view for child in node.children)
         |         |
         |         +-- @py len(node.parent.children)
         |         |
         |         +-- @py(a=1) 1 + a
         |         |
         |         +-- @py 100

If we were to evaluate or view the ``@py sum(..)`` node we would get 105 as an int result.  One can imagine uses along the lines of a tree-based spreadsheet, command-tree, script collection, etc..

Perhaps the above example looks wordy, but that's because we're trying to be explicit and illustrative of different possible forms. The @csum directive, which is defined later in this section, implements a custom child-summing function which allows for a more concise style.

The other functional directive that is being used above is ``@pyc``::

    @directive('pyc', 'py-suite')
    def eval_py_suite(**kwds):
        """ creates and registers an @pyc directive
        """
        def _eval_py_suite(element):
            exec element.code in element.node.namespace
        return _eval_py_suite


``@pyc`` creates a python suite or block of code which gets executed in the node's namespace.

.. note:: As you have probably noticed the implementation of this concept embraces eval and exec of arbitrary code in a leo tree. Although this has its dangers, code evaluation is an explicit request from the user who should know that running bits of a leo tree is as dangerous as running other people's python code.


</t>
<t tx="sa.20091017143710.1576">leofunc_plugin.py
</t>
<t tx="sa.20111215010755.1632"></t>
<t tx="sa.20111215010755.1638"></t>
<t tx="sa.20111215010755.1654">@pyc
node.body.data = a * 2132
@
some data in the body
</t>
<t tx="sa.20111215010755.1655">@imports
import xml    
@
hello
</t>
<t tx="sa.20111215010755.1656">@pyc
import math
a = 10
b = a * math.pi
assert a &lt; b
node.body.data = a * 2132
node.body.view = "hello"
@
some data in the body
</t>
<t tx="sa.20111215010755.1657">@template
Is it really $date ?
@
some body text
</t>
<t tx="sa.20111215010755.1658">this is a body</t>
</tnodes>
</leo_file>
